const util = require('node:util');
const exec = util.promisify(require('node:child_process').exec);
const { resolve } = require('node:path');
const rm = util.promisify(require('node:fs').rm);

/*
 * Finds the git repository path, cloning the MicroSDeck repository if necessary.
 * 
 * @returns {Promise<{path: string?, cleanup: async () => void}>} Path o the git repository
* */
async function ensureGitRepo() {
	const { Version } = await import('../../util/versioning.mjs');

	let gitRepoPath = await (async () => {
		try {
			let { stdout } = await exec('git rev-parse --git-dir', { stdio: 'ignore' });

			// want to resolve to an absolute path since it sometimes returns relative paths
			return resolve(stdout.trim());
		}
		catch {
			return null;
		}
	})();

	if (!gitRepoPath) {
		// We are not within a git repository, lets change that :P
		console.log(`Retrieving MicroSDeck changelog (version: ${Version})...`);

		try {
			await exec(`git clone --bare --branch "${Version}" https://github.com/CEbbinghaus/MicroSDeck.git .msdeck.git`, { stdio: 'pipe' });
			return {
				gitPath: resolve('.msdeck.git'),
				cleanup: async () => {
					await rm(resolve('.msdeck.git'), { recursive: true, force: true });
				}
			};
		} catch (e) {
			console.error(`Unable to find tag ${Version} in MicroSDeck repository.\nstderr:\n`, e.stderr.toString());
			process.exit(1);
		}
	} else {
		const numCommits = parseInt((await exec('git rev-list --count HEAD')).stdout.trim());
		if (numCommits == 1) {
			console.log('In shallow git clone, fetching full history...');
			// We are in a shallow clone, lets fix that
			await exec('git fetch --unshallow', { stdio: 'ignore' });
		}
		return { gitPath: gitRepoPath, cleanup: async () => { } };
	}
}

/*
 * Generates a mapping of commit hashes to tags.
 * 
 * @param {string} gitDirectory - the directory of the git repository
 * @returns {Promise<Object<string, string>>} A mapping of commit hashes to tags.
* */
async function generateTagObject(gitRepository) {
	const tagLog = (await exec(`git --git-dir="${gitRepository}" log --tags --no-walk --pretty="%H %S"`)).stdout.trim();

	let additionalTags = [];

	let masterCommit = null;
	try {
		masterCommit = (await exec(`git --git-dir="${gitRepository}" rev-parse master`)).stdout.trim();
	} catch (_) { }

	const head = (await exec(`git --git-dir="${gitRepository}" rev-list --parents -1 HEAD`)).stdout.trim();
	let [headCommit, parentCommit, mergeCommit] = head.split(' ');

	if (mergeCommit) {
		// Github "helpfully" runs an action in a "merged" state. So we need to untangle the merge into its individual parts
		masterCommit = parentCommit;
		headCommit = mergeCommit;
	}

	if (masterCommit) {
		const masterVersion = (await exec(`git --git-dir="${gitRepository}" show ${masterCommit}:backend/version`)).stdout.trim();
		additionalTags = [
			[masterCommit, `master @ ${masterCommit.substring(0, 7)} (${masterVersion})`],
			...additionalTags
		];
	}

	// This is not built on latest master so we are gonna display info on this branch
	if (additionalTags.length == 0 || masterCommit !== headCommit) {
		let branchName = (await exec(`git --git-dir="${gitRepository}" rev-parse --abbrev-ref HEAD`)).stdout.trim();

		// The merge commit does not track the branch name so we need to retrieve it from Github Env
		if (branchName === 'HEAD' && process.env.GITHUB_REF) {
			// Detached HEAD, try to find branch name via github env variable
			branchName = process.env.GITHUB_REF.replace('refs/heads/', '');
		}

		additionalTags = [
			[headCommit, `${branchName} @ ${headCommit.substring(0, 7)} (Pre-Release)`],
			...additionalTags
		];
	}

	const tagArray = [
		...additionalTags,
		...tagLog.split('\n').map(line => {
			const [hash, tag] = line.split(' ');
			return [hash, tag];
		})
	]

	return Object.fromEntries(tagArray);
}


/*
 * Generates an array of commits grouped by tag
 * 
 * @param {string} gitDirectory - the directory of the git repository
 * @param {Object<string, string>} tags - A mapping of commit hashes to tags.
 * @returns {Promise<Array<{tag: string, commits: Array<{hash: string, author: string, email: string, message: string}>}>>} An array of tagged commits.
 */
async function generateTaggedCommits(gitRepository, tags) {
	const commitLog = (await exec(`git --git-dir="${gitRepository}" log --no-merges --pretty="%H %aN %aE %s"`)).stdout.trim();
	const commits = commitLog.split('\n').map(line => {
		const [hash, author, email, ...message] = line.split(' ');
		return { hash, author, email, message: message.join(' ') };
	});

	const taggedCommits = [];

	for (let i = 0; i < commits.length;) {
		let taggedCommit = { tag: tags[commits[i].hash], commits: [] };

		do {
			taggedCommit.commits.push(commits[i]);
		}
		while (++i < commits.length && !tags[commits[i].hash]);

		taggedCommits.push(taggedCommit);
	}
	return taggedCommits;
}


module.exports = async function () {
	const { gitPath, cleanup } = await ensureGitRepo();
	const tags = await generateTagObject(gitPath);
	const taggedCommits = await generateTaggedCommits(gitPath, tags);
	await cleanup();
	return `
//@ts-nocheck
export default ${JSON.stringify(taggedCommits)};
	`;
};
